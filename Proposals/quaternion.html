<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 5.4.5.1 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="2018-02-28T08:19:32.384704085"/>
	<style type="text/css">
		h2.cjk { font-family: "WenQuanYi Micro Hei" }
		h2.ctl { font-family: "Lohit Devanagari" }
		pre.cjk { font-family: "WenQuanYi Micro Hei Mono", monospace }
		h5.cjk { font-family: "WenQuanYi Micro Hei" }
		h5.ctl { font-family: "Lohit Devanagari" }
		h4.cjk { font-family: "WenQuanYi Micro Hei" }
		h4.ctl { font-family: "Lohit Devanagari" }
		code.cjk { font-family: "WenQuanYi Micro Hei Mono", monospace }
	</style>
</head>
<body lang="ru-RU" dir="ltr">
<h1 align="center"><strong>Proposal about Quaternions</strong></h1>
<p align="right"><strong>Document number:&nbsp;</strong></p>
<p align="right"><strong>Date:&nbsp;</strong></p>
<p align="right"><strong>Project:&nbsp;</strong>Programming Language
C++</p>
<p align="right"><strong>Reference:&nbsp;</strong>ISO/IEC IS
14882:2017(E)</p>
<p align="right"><strong>Reply to:</strong>&nbsp;Alexander Zaitsev</p>
<p align="right">zamazan4ik@tut.by</p>
<p align="right">&nbsp;</p>
<h2 class="western" align="left"><strong>Overview</strong></h2>
<p>At the current time in the standard, we already have class for
working with complex numbers - std::complex. But there are another
mathmatical types. One of them are quaternions. This document propose
new header - &lt;quaternion&gt;, and new class - quaternion</p>
<h2 class="western">Description</h2>
<p><br/>
<br/>

</p>
<h2 class="western"><strong>Header &lt;quaternion&gt; synopsis</strong></h2>
<p>namespace std</p>
<p>{</p>
<pre class="western">template&lt;typename T&gt; class <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat.html">quaternion</a>;
template&lt;&gt;           class <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/spec.html">quaternion&lt;float&gt;</a>;
template&lt;&gt;           class <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/spec.html#math_quaternion_double">quaternion&lt;double&gt;</a>;
template&lt;&gt;           class <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/spec.html#math_quaternion_long_double">quaternion&lt;long double&gt;</a>;

// operators
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_addition_operators">operator +</a> (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_addition_operators">operator +</a> (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_addition_operators">operator +</a> (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_addition_operators">operator +</a> (quaternion&lt;T&gt; const &amp; lhs, ::std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_addition_operators">operator +</a> (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);

template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_subtraction_operators">operator -</a> (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_subtraction_operators">operator -</a> (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_subtraction_operators">operator -</a> (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_subtraction_operators">operator -</a> (quaternion&lt;T&gt; const &amp; lhs, ::std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_subtraction_operators">operator -</a> (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);

template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_multiplication_operators">operator *</a> (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_multiplication_operators">operator *</a> (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_multiplication_operators">operator *</a> (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_multiplication_operators">operator *</a> (quaternion&lt;T&gt; const &amp; lhs, ::std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_multiplication_operators">operator *</a> (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);

template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_division_operators">operator /</a> (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_division_operators">operator /</a> (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_division_operators">operator /</a> (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_division_operators">operator /</a> (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.binary_division_operators">operator /</a> (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);

template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.unary_plus">operator +</a> (quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.unary_minus">operator -</a> (quaternion&lt;T&gt; const &amp; q);

template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.equality_operators">operator ==</a> (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.equality_operators">operator ==</a> (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.equality_operators">operator ==</a> (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.equality_operators">operator ==</a> (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.equality_operators">operator ==</a> (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);

template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.inequality_operators">operator !=</a> (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.inequality_operators">operator !=</a> (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.inequality_operators">operator !=</a> (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.inequality_operators">operator !=</a> (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.inequality_operators">operator !=</a> (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);

template&lt;typename T, typename charT, class traits&gt;
std::basic_istream&lt;charT,traits&gt;&amp; <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.stream_extractor">operator &gt;&gt;</a> (std::basic_istream&lt;charT,traits&gt; &amp; is, quaternion&lt;T&gt; &amp; q);

template&lt;typename T, typename charT, class traits&gt;
std::basic_ostream&lt;charT,traits&gt;&amp; operator <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_non_mem.html#math_toolkit.quat_non_mem.stream_inserter">operator &lt;&lt;</a> (std::basic_ostream&lt;charT,traits&gt; &amp; os, quaternion&lt;T&gt; const &amp; q);

// values
template&lt;typename T&gt; constexpr T              <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.real_and_unreal">real</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.real_and_unreal">unreal</a>(quaternion&lt;T&gt; const &amp; q);

template&lt;typename T&gt; constexpr T              <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.sup">sup</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; constexpr T              <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.l1">l1</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; constexpr T              <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.abs">abs</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; constexpr T              <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.norm">norm</a>(quaternion&lt;T&gt;const  &amp; q);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/value_op.html#math_toolkit.value_op.conj">conj</a>(quaternion&lt;T&gt; const &amp; q);

template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/create.html#math_quaternions.creation_spherical">spherical</a>(T const &amp; rho, T const &amp; theta, T const &amp; phi1, T const &amp; phi2);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/create.html#math_quaternions.creation_semipolar">semipolar</a>(T const &amp; rho, T const &amp; alpha, T const &amp; theta1, T const &amp; theta2);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/create.html#math_quaternions.creation_multipolar">multipolar</a>(T const &amp; rho1, T const &amp; theta1, T const &amp; rho2, T const &amp; theta2);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/create.html#math_quaternions.creation_cylindrospherical">cylindrospherical</a>(T const &amp; t, T const &amp; radius, T const &amp; longitude, T const &amp; latitude);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/create.html#math_quaternions.creation_cylindrical">cylindrical</a>(T const &amp; r, T const &amp; angle, T const &amp; h1, T const &amp; h2);

// transcendentals
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.exp">exp</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.cos">cos</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.sin">sin</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.tan">tan</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.cosh">cosh</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.sinh">sinh</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.tanh">tanh</a>(quaternion&lt;T&gt; const &amp; q);
template&lt;typename T&gt; quaternion&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/trans.html#math_toolkit.trans.pow">pow</a>(quaternion&lt;T&gt; const &amp; q, int n);</pre><p>
}</p>
<h2 class="western">Class quaternion</h2>
<pre class="western">template&lt;typename T&gt;
class quaternion
{
public:

   typedef T <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/mem_typedef.html">value_type</a>;

   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(T const &amp; requested_a = T(), T const &amp; requested_b = T(), T const &amp; requested_c = T(), T const &amp; requested_d = T());
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(std::complex&lt;T&gt; const &amp; z0, std::complex&lt;T&gt; const &amp; z1 = std::complex&lt;T&gt;());
   template&lt;typename X&gt;
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;X&gt; const &amp; a_recopier);

   constexpr T                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">real</a>() const;
   constexpr quaternion&lt;T&gt;      <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">unreal</a>() const;
   constexpr T                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_1</a>() const;
   constexpr T                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_2</a>() const;
   constexpr T                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_3</a>() const;
   constexpr T                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_4</a>() const;
   constexpr std::complex&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_1</a>() const;
   constexpr std::complex&lt;T&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_2</a>() const;

   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;T&gt; const  &amp; a_affecter);
   template&lt;typename X&gt;
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;X&gt; const  &amp; a_affecter);
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(T const  &amp; a_affecter);
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(std::complex&lt;T&gt; const &amp; a_affecter);

   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(T const &amp; rhs);
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(std::complex&lt;T&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(T const &amp; rhs);
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(std::complex&lt;T&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(T const &amp; rhs);
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(std::complex&lt;T&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(T const &amp; rhs);
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(std::complex&lt;T&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;T&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(quaternion&lt;X&gt; const &amp; rhs);
};</pre><h2 class="western">
<strong>Details</strong></h2>
<h2 class="western">Class quaternion specializations</h2>
<pre class="western">template&lt;&gt;
class quaternion&lt;float&gt;
{
public:
   typedef float <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/mem_typedef.html">value_type</a>;

   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(float const &amp; requested_a = 0.0f, float const &amp; requested_b = 0.0f, float const &amp; requested_c = 0.0f, float const &amp; requested_d = 0.0f);
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(std::complex&lt;float&gt; const &amp; z0, std::complex&lt;float&gt; const &amp; z1 = std::complex&lt;float&gt;());
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;double&gt; const &amp; a_recopier);
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;long double&gt; const &amp; a_recopier);

   constexpr float                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">real</a>() const;
   constexpr quaternion&lt;float&gt;      <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">unreal</a>() const;
   constexpr float                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_1</a>() const;
   constexpr float                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_2</a>() const;
   constexpr float                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_3</a>() const;
   constexpr float                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_4</a>() const;
   constexpr std::complex&lt;float&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_1</a>() const;
   constexpr std::complex&lt;float&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_2</a>() const;

   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;float&gt; const  &amp; a_affecter);
   template&lt;typename X&gt;
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;X&gt; const  &amp; a_affecter);
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(float const  &amp; a_affecter);
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(std::complex&lt;float&gt; const &amp; a_affecter);

   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(float const &amp; rhs);
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(std::complex&lt;float&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(float const &amp; rhs);
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(std::complex&lt;float&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(float const &amp; rhs);
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(std::complex&lt;float&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(float const &amp; rhs);
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(std::complex&lt;float&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;float&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(quaternion&lt;X&gt; const &amp; rhs);
};
<a name="math_quaternion_double"></a>template&lt;&gt;
class quaternion&lt;double&gt;
{
public:
   typedef double <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/mem_typedef.html">value_type</a>;

   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(double const &amp; requested_a = 0.0, double const &amp; requested_b = 0.0, double const &amp; requested_c = 0.0, double const &amp; requested_d = 0.0);
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(std::complex&lt;double&gt; const &amp; z0, std::complex&lt;double&gt; const &amp; z1 = std::complex&lt;double&gt;());
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;float&gt; const &amp; a_recopier);
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;long double&gt; const &amp; a_recopier);

   constexpr double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">real</a>() const;
   constexpr quaternion&lt;double&gt;      <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">unreal</a>() const;
   constexpr double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_1</a>() const;
   constexpr double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_2</a>() const;
   constexpr double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_3</a>() const;
   constexpr double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_4</a>() const;
   constexpr std::complex&lt;double&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_1</a>() const;
   constexpr std::complex&lt;double&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_2</a>() const;

   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;double&gt; const  &amp; a_affecter);
   template&lt;typename X&gt;
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;X&gt; const  &amp; a_affecter);
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(double const  &amp; a_affecter);
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(std::complex&lt;double&gt; const &amp; a_affecter);

   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(double const &amp; rhs);
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(std::complex&lt;double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(double const &amp; rhs);
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(std::complex&lt;double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(double const &amp; rhs);
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(std::complex&lt;double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(double const &amp; rhs);
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(std::complex&lt;double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(quaternion&lt;X&gt; const &amp; rhs);
};
<a name="math_quaternion_long_double"></a>template&lt;&gt;
class quaternion&lt;long double&gt;
{
public:
   typedef long double <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/mem_typedef.html">value_type</a>;

   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(long double const &amp; requested_a = 0.0L, long double const &amp; requested_b = 0.0L, long double const &amp; requested_c = 0.0L, long double const &amp; requested_d = 0.0L);
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(std::complex&lt;long double&gt; const &amp; z0, std::complex&lt;long double&gt; const &amp; z1 = std::complex&lt;long double&gt;());
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;float&gt; const &amp; a_recopier);
   constexpr explicit <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.constructors">quaternion</a>(quaternion&lt;double&gt; const &amp; a_recopier);

   constexpr long double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">real</a>() const;
   constexpr quaternion&lt;long double&gt;      <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.real_and_unreal_parts">unreal</a>() const;
   constexpr long double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_1</a>() const;
   constexpr long double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_2</a>() const;
   constexpr long double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_3</a>() const;
   constexpr long double                  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_real_components">R_component_4</a>() const;
   constexpr std::complex&lt;long double&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_1</a>() const;
   constexpr std::complex&lt;long double&gt;  <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.individual_complex_components">C_component_2</a>() const;

   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;long double&gt; const  &amp; a_affecter);
   template&lt;typename X&gt;
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(quaternion&lt;X&gt; const  &amp; a_affecter);
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(long double const  &amp; a_affecter);
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.assignment_operators">operator = </a>(std::complex&lt;long double&gt; const &amp; a_affecter);

   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(long double const &amp; rhs);
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(std::complex&lt;long double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.addition_operators">operator += </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(long double const &amp; rhs);
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(std::complex&lt;long double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.subtraction_operators">operator -= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(long double const &amp; rhs);
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(std::complex&lt;long double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.multiplication_operators">operator *= </a>(quaternion&lt;X&gt; const &amp; rhs);

   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(long double const &amp; rhs);
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(std::complex&lt;long double&gt; const &amp; rhs);
   template&lt;typename X&gt;
   constexpr quaternion&lt;long double&gt;&amp;     <a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html#math_toolkit.quat_mem_fun.division_operators">operator /= </a>(quaternion&lt;X&gt; const &amp; rhs);
};</pre><h2 class="western">
Details</h2>
<pre class="western">template&lt;typename T&gt; T real(quaternion&lt;T&gt; const &amp; q);
Returns q.real().

template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  unreal(quaternion&lt;T&gt; const &amp; q);</pre><p>
Returns&nbsp;<code class="western">q.unreal()</code>.</p>
<p><br/>
<br/>

</p>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; constexpr quaternion&lt;T&gt;  conj(quaternion&lt;T&gt; const &amp; q);</pre><p>
Returns the conjugate of the quaternion.</p>
<p><br/>
<br/>

</p>
<h5 class="western"><br/>
<br/>

</h5>
<p>template&lt;typename T&gt; constexpr T sup(quaternion&lt;T&gt;
const &amp; q);</p>
<p>Returns the sup norm (the greatest
among&nbsp;<code class="western">abs(q.R_component_1()),&nbsp;abs(q.R_component_2()),&nbsp;abs(q.R_component_3()),&nbsp;abs(q.R_component_4()))</code>&nbsp;of
the quaternion.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; constexpr T l1(quaternion&lt;T&gt; const &amp; q);</pre><p>
Returns the l1 norm&nbsp;<code class="western">(abs(q.R_component_1())
+&nbsp;abs(q.R_component_2()) +&nbsp;abs(q.R_component_3())
+&nbsp;abs(q.R_component_4()))</code>&nbsp;of the quaternion.</p>
<p><br/>
<br/>

</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; constexpr T  abs(quaternion&lt;T&gt; const &amp; q);</pre><p>
Returns the magnitude (Euclidian norm) of the quaternion.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; constexpr T norm(quaternion&lt;T&gt;const  &amp; q);</pre><p>
Returns the (Cayley) norm of the quaternion. The term &quot;norm&quot;
might be confusing, as most people associate it with the Euclidian
norm (and quadratic functionals). For this version of (the
mathematical objects known as) quaternions, the Euclidian norm (also
known as magnitude) is the square root of the Cayley norm.</p>
<h2 class="western"><a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html">Quaternion
Member Functions</a></h2>
<h4 class="western">Constructors</h4>
<p>Template version:</p>
<pre class="western">constexpr explicit quaternion(T const &amp; requested_a = T(), T const &amp; requested_b = T(), T const &amp; requested_c = T(), T const &amp; requested_d = T());
constexpr explicit quaternion(std::complex&lt;T&gt; const &amp; z0, std::complex&lt;T&gt; const &amp; z1 = std::complex&lt;T&gt;());
template&lt;typename X&gt;
constexpr explicit quaternion(quaternion&lt;X&gt; const &amp; a_recopier);</pre><p>
Float specialization version:</p>
<pre class="western">constexpr explicit quaternion(float const &amp; requested_a = 0.0f, float const &amp; requested_b = 0.0f, float const &amp; requested_c = 0.0f, float const &amp; requested_d = 0.0f);
constexpr explicit quaternion(std::complex&lt;float&gt; const &amp; z0, std::complex&lt;float&gt; const &amp; z1 = std::complex&lt;float&gt;());
constexpr explicit quaternion(quaternion&lt;double&gt; const &amp; a_recopier);
constexpr explicit quaternion(quaternion&lt;long double&gt; const &amp; a_recopier);</pre><p>
Double specialization version:</p>
<pre class="western">constexpr explicit quaternion(double const &amp; requested_a = 0.0, double const &amp; requested_b = 0.0, double const &amp; requested_c = 0.0, double const &amp; requested_d = 0.0);
constexpr explicit quaternion(::std::complex&lt;double&gt; const &amp; z0, std::complex&lt;double&gt; const &amp; z1 = std::complex&lt;double&gt;());
constexpr explicit quaternion(quaternion&lt;float&gt; const &amp; a_recopier);
constexpr explicit quaternion(quaternion&lt;long double&gt; const &amp; a_recopier);</pre><p>
Long double specialization version:</p>
<pre class="western">constexpr explicit quaternion(long double const &amp; requested_a = 0.0L, long double const &amp; requested_b = 0.0L, long double const &amp; requested_c = 0.0L, long double const &amp; requested_d = 0.0L);
constexpr explicit quaternion(std::complex&lt;long double&gt; const &amp; z0, std::complex&lt;long double&gt; const &amp; z1 = std::complex&lt;long double&gt;());
constexpr explicit quaternion(quaternion&lt;float&gt; const &amp; a_recopier);
constexpr explicit quaternion(quaternion&lt;double&gt; const &amp; a_recopier);</pre><p>
A default constructor is provided for each form, which initializes
each component to the default values for their type (i.e. zero for
floating numbers). This constructor can also accept one to four base
type arguments. A constructor is also provided to build quaternions
from one or two complex numbers sharing the same base type. The
unspecialized template also sports a templarized copy constructor,
while the specialized forms have copy constructors from the other two
specializations, which are explicit when a risk of precision loss
exists. For the unspecialized form, the base type's constructors must
not throw.</p>
<p>Destructors and untemplated copy constructors (from the same type)
are provided by the compiler. Converting copy constructors make use
of a templated helper function in a &quot;detail&quot; subnamespace.</p>
<h4 class="western">Other member functions</h4>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">constexpr T             real() const;
constexpr quaternion&lt;T&gt; unreal() const;</pre><p>
Like complex number, quaternions do have a meaningful notion of &quot;real
part&quot;, but unlike them there is no meaningful notion of
&quot;imaginary part&quot;. Instead there is an &quot;unreal part&quot;
which itself is a quaternion, and usually nothing simpler (as opposed
to the complex number case). These are returned by the first two
functions.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">constexpr T R_component_1() const;
constexpr T R_component_2() const;
constexpr T R_component_3() const;
constexpr T R_component_4() const;</pre><p>
A quaternion having four real components, these are returned by these
four functions. Hence real and R_component_1 return the same value.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">constexpr std::complex&lt;T&gt;  C_component_1() const;
constexpr std::complex&lt;T&gt;  C_component_2() const;</pre><p>
A quaternion likewise has two complex components, and as we have seen
above, for any quaternion&nbsp;<em><code class="western">q = α + βi
+ γj + δk</code></em>&nbsp;we also have&nbsp;<em><code class="western">q
= (α + βi) + (γ + δi)j&nbsp;</code></em>. These functions return
them. The real part of&nbsp;<code class="western">q.C_component_1()</code>&nbsp;is
the same as&nbsp;<code class="western">q.real()</code>.</p>
<h4 class="western">Quaternion Member Operators</h4>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">constexpr quaternion&lt;T&gt;&amp; operator = (quaternion&lt;T&gt; const &amp; a_affecter);
template&lt;typename X&gt;
constexpr quaternion&lt;T&gt;&amp; operator = (quaternion&lt;X&gt; const&amp; a_affecter);
constexpr quaternion&lt;T&gt;&amp; operator = (T const&amp; a_affecter);
constexpr quaternion&lt;T&gt;&amp; operator = (std::complex&lt;T&gt; const&amp; a_affecter);</pre><p>
These perform the expected assignment, with type modification if
necessary (for instance, assigning from a base type will set the real
part to that value, and all other components to zero). For the
unspecialized form, the base type's assignment operators must not
throw.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">constexpr quaternion&lt;T&gt;&amp; operator += (T const &amp; rhs)
constexpr quaternion&lt;T&gt;&amp; operator += (std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename X&gt;
constexpr quaternion&lt;T&gt;&amp; operator += (quaternion&lt;X&gt; const &amp; rhs);</pre><p>
These perform the mathematical operation&nbsp;<code class="western">(*this)+rhs</code>&nbsp;and
store the result in&nbsp;<code class="western">*this</code>. The
unspecialized form has exception guards, which the specialized forms
do not, so as to insure exception safety. For the unspecialized form,
the base type's assignment operators must not throw.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">constexpr quaternion&lt;T&gt;&amp; operator -= (T const &amp; rhs)
constexpr quaternion&lt;T&gt;&amp; operator -= (std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename X&gt;
constexpr quaternion&lt;T&gt;&amp; operator -= (quaternion&lt;X&gt; const &amp; rhs);</pre><p>
These perform the mathematical operation&nbsp;<code class="western">(*this)-rhs</code>&nbsp;and
store the result in&nbsp;<code class="western">*this</code>. The
unspecialized form has exception guards, which the specialized forms
do not, so as to insure exception safety. For the unspecialized form,
the base type's assignment operators must not throw.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">constexpr quaternion&lt;T&gt;&amp; operator *= (T const &amp; rhs)
constexpr quaternion&lt;T&gt;&amp; operator *= (std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename X&gt;
constexpr quaternion&lt;T&gt;&amp; operator *= (quaternion&lt;X&gt; const &amp; rhs);</pre><p>
These perform the mathematical operation&nbsp;<code class="western">(*this)*rhs</code>&nbsp;<strong>in
this order</strong>&nbsp;(order is important as multiplication is not
commutative for quaternions) and store the result in&nbsp;<code class="western">*this</code>.
The unspecialized form has exception guards, which the specialized
forms do not, so as to insure exception safety. For the unspecialized
form, the base type's assignment operators must not throw.</p>
<p><br/>
<br/>

</p>
<pre class="western">constexpr quaternion&lt;T&gt;&amp; operator /= (T const &amp; rhs)
constexpr quaternion&lt;T&gt;&amp; operator /= (std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename X&gt;
constexpr quaternion&lt;T&gt;&amp; operator /= (quaternion&lt;X&gt; const &amp; rhs);</pre><p>
These perform the mathematical operation&nbsp;<code class="western">(*this)*inverse_of(rhs)</code>&nbsp;<strong>in
this order</strong>&nbsp;(order is important as multiplication is not
commutative for quaternions) and store the result in&nbsp;<code class="western">*this</code>.
The unspecialized form has exception guards, which the specialized
forms do not, so as to insure exception safety. For the unspecialized
form, the base type's assignment operators must not throw.</p>
<h2 class="western">Quaternion Non-Member Operators</h2>
<pre class="western">template&lt;typename T&gt;
constexpr quaternion&lt;T&gt; operator + (quaternion&lt;T&gt; const &amp; q);</pre><p>
This unary operator simply returns q.</p>
<p><br/>
<br/>

</p>
<pre class="western">template&lt;typename T&gt;
constexpr quaternion&lt;T&gt; operator - (quaternion&lt;T&gt; const &amp; q);</pre><p>
This unary operator returns the opposite of q.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator + (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator + (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator + (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator + (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator + (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);</pre><p>
These operators return <code class="western">quaternion&lt;T&gt;(lhs)&nbsp;+=&nbsp;rhs</code>.</p>
<h5 class="western"><br/>
<br/>

</h5>
<pre class="western">template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator - (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator - (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator - (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator - (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator - (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);</pre><p>
These operators return&nbsp;<code class="western">quaternion&lt;T&gt;(lhs)&nbsp;-=&nbsp;rhs</code>.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator * (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator * (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator * (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator * (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator * (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);</pre><p>
These operators return&nbsp;<code class="western">quaternion&lt;T&gt;(lhs)&nbsp;*=&nbsp;rhs</code>.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator / (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator / (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator / (std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator / (quaternion&lt;T&gt; const &amp; lhs, std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; operator / (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);</pre><p>
These operators return&nbsp;<code class="western">quaternion&lt;T&gt;(lhs)&nbsp;/=&nbsp;rhs</code>.
Dividing by zero is Undefined behavior.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">template&lt;typename T&gt; constexpr bool  operator == (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator == (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator == (::std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator == (quaternion&lt;T&gt; const &amp; lhs, ::std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator == (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);</pre><p>
These return true if and only if the four components
of&nbsp;<code class="western">quaternion&lt;T&gt;(lhs)</code>&nbsp;are
equal to their counterparts in&nbsp;<code class="western">quaternion&lt;T&gt;(rhs)</code>.
As with any floating-type entity, this is essentially meaningless.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">template&lt;typename T&gt; constexpr bool  operator != (T const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator != (quaternion&lt;T&gt; const &amp; lhs, T const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator != (::std::complex&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator != (quaternion&lt;T&gt; const &amp; lhs, ::std::complex&lt;T&gt; const &amp; rhs);
template&lt;typename T&gt; constexpr bool  operator != (quaternion&lt;T&gt; const &amp; lhs, quaternion&lt;T&gt; const &amp; rhs);</pre><p>
These return true if and only
if&nbsp;<code class="western">quaternion&lt;T&gt;(lhs)&nbsp;==&nbsp;quaternion&lt;T&gt;(rhs)</code>&nbsp;is
false. As with any floating-type entity, this is essentially
meaningless.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">template&lt;typename T, typename charT, class traits&gt;
std::basic_istream&lt;charT,traits&gt;&amp; operator &gt;&gt; (::std::basic_istream&lt;charT,traits&gt; &amp; is, quaternion&lt;T&gt; &amp; q);</pre><p>
Extracts a quaternion q of one of the following forms (with a, b, c
and d of type&nbsp;<code class="western">T</code>):</p>
<p><code class="western">a (a), (a,b), (a,b,c), (a,b,c,d) (a,(c)),
(a,(c,d)), ((a)), ((a),c), ((a),(c)), ((a),(c,d)), ((a,b)),
((a,b),c), ((a,b),(c)), ((a,b),(c,d))</code></p>
<p>The input values must be convertible to&nbsp;<code class="western">T</code>.
If bad input is encountered, calls&nbsp;<code class="western">is.setstate(ios::failbit)</code>&nbsp;(which
may throw ios::failure (27.4.5.3)).</p>
<p><strong>Returns:</strong>&nbsp;<code class="western">is</code>.</p>
<p>The rationale for the list of accepted formats is that either we
have a list of up to four reals, or else we have a couple of complex
numbers, and in that case if it formated as a proper complex number,
then it should be accepted. Thus potential ambiguities are lifted
(for instance (a,b) is (a,b,0,0) and not (a,0,b,0), i.e. it is parsed
as a list of two real numbers and not two complex numbers which
happen to have imaginary parts equal to zero).</p>
<h5 class="western">&nbsp;</h5>
<pre class="western">template&lt;typename T, typename charT, class traits&gt;
std::basic_ostream&lt;charT,traits&gt;&amp; operator &lt;&lt; (::std::basic_ostream&lt;charT,traits&gt; &amp; os, quaternion&lt;T&gt; const &amp; q);</pre><p>
Inserts the quaternion q onto the stream&nbsp;<code class="western">os</code>&nbsp;as
if it were implemented as follows:</p>
<pre class="western">template&lt;typename T, typename charT, class traits&gt;
std::basic_ostream&lt;charT,traits&gt;&amp; operator &lt;&lt; (
               std::basic_ostream&lt;charT,traits&gt; &amp; os,
               quaternion&lt;T&gt; const &amp; q)
{
   std::basic_ostringstream&lt;charT,traits&gt;  s;

   s.flags(os.flags());
   s.imbue(os.getloc());
   s.precision(os.precision());

   s &lt;&lt; '(' &lt;&lt; q.R_component_1() &lt;&lt; ','
            &lt;&lt; q.R_component_2() &lt;&lt; ','
            &lt;&lt; q.R_component_3() &lt;&lt; ','
            &lt;&lt; q.R_component_4() &lt;&lt; ')';

   return os &lt;&lt; s.str();
}
template&lt;typename T&gt; quaternion&lt;T&gt; exp(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the exponential of the quaternion.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  cos(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the cosine of the quaternion</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  sin(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the sine of the quaternion.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  tan(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the tangent of the quaternion.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  cosh(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the hyperbolic cosine of the quaternion.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  sinh(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the hyperbolic sine of the quaternion.</p>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  tanh(quaternion&lt;T&gt; const &amp; q);</pre><p>
Computes the hyperbolic tangent of the quaternion.</p>
<h5 class="western">&nbsp;</h5>
<pre class="western" style="margin-bottom: 0.5cm">template&lt;typename T&gt; quaternion&lt;T&gt;  pow(quaternion&lt;T&gt; const &amp; q, int n);</pre><p>
Computes the n-th power of the quaternion q.</p>
<h2 class="western">Quaternion Creation Functions</h2>
<pre class="western">template&lt;typename T&gt; constexpr quaternion&lt;T&gt; spherical(T const &amp; rho, T const &amp; theta, T const &amp; phi1, T const &amp; phi2);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; semipolar(T const &amp; rho, T const &amp; alpha, T const &amp; theta1, T const &amp; theta2);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; multipolar(T const &amp; rho1, T const &amp; theta1, T const &amp; rho2, T const &amp; theta2);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; cylindrospherical(T const &amp; t, T const &amp; radius, T const &amp; longitude, T const &amp; latitude);
template&lt;typename T&gt; constexpr quaternion&lt;T&gt; cylindrical(T const &amp; r, T const &amp; angle, T const &amp; h1, T const &amp; h2);</pre><p>
These build quaternions in a way similar to the way polar builds
complex numbers, as there is no strict equivalent to polar
coordinates for quaternions.</p>
<p><code class="western">spherical</code>&nbsp;is a simple
transposition of&nbsp;<code class="western">polar</code>, it takes as
inputs a (positive) magnitude and a point on the hypersphere, given
by three angles. The first of these,&nbsp;<code class="western">theta</code>&nbsp;has
a natural range of&nbsp;<code class="western">-pi</code>&nbsp;to&nbsp;<code class="western">+pi</code>,
and the other two have natural ranges of&nbsp;<code class="western">-pi/2</code>&nbsp;to&nbsp;<code class="western">+pi/2</code>&nbsp;(as
is the case with the usual spherical coordinates in&nbsp;<em><strong>R</strong></em><em><strong><sup>3</sup></strong></em>).
Due to the many symmetries and periodicities, nothing untoward
happens if the magnitude is negative or the angles are outside their
natural ranges. The expected degeneracies (a magnitude of zero
ignores the angles settings...) do happen however.</p>
<p><code class="western">cylindrical</code>&nbsp;is likewise a simple
transposition of the usual cylindrical coordinates in&nbsp;<em><strong>R</strong></em><em><strong><sup>3</sup></strong></em>,
which in turn is another derivative of planar polar coordinates. The
first two inputs are the polar coordinates of the first&nbsp;<em><strong>C</strong></em>&nbsp;component
of the quaternion. The third and fourth inputs are placed into the
third and fourth&nbsp;<em><strong>R</strong></em>&nbsp;components of
the quaternion, respectively.</p>
<p><code class="western">multipolar</code>&nbsp;is yet another simple
generalization of polar coordinates. This time, both&nbsp;<em><strong>C</strong></em>&nbsp;components
of the quaternion are given in polar coordinates.</p>
<p><code class="western">cylindrospherical</code>&nbsp;is specific to
quaternions. It is often interesting to consider&nbsp;<em><strong>H</strong></em>&nbsp;as
the cartesian product of&nbsp;<em><strong>R</strong></em>&nbsp;by&nbsp;<em><strong>R</strong></em><em><strong><sup>3</sup></strong></em>&nbsp;(the
quaternionic multiplication as then a special form, as given here).
This function therefore builds a quaternion from this representation,
with the&nbsp;<em><strong>R</strong></em><em><strong><sup>3</sup></strong></em>&nbsp;component
given in usual&nbsp;<em><strong>R</strong></em><em><strong><sup>3</sup></strong></em>&nbsp;spherical
coordinates.</p>
<p><code class="western">semipolar</code>&nbsp;is another generator
which is specific to quaternions. It takes as a first input the
magnitude of the quaternion, as a second input an angle in the
range&nbsp;<code class="western">0</code>&nbsp;to&nbsp;<code class="western">+pi/2</code>&nbsp;such
that magnitudes of the first two&nbsp;<em><strong>C</strong></em>&nbsp;components
of the quaternion are the product of the first input and the sine and
cosine of this angle, respectively, and finally as third and fourth
inputs angles in the range&nbsp;<code class="western">-pi/2</code>&nbsp;to&nbsp;<code class="western">+pi/2</code>&nbsp;which
represent the arguments of the first and second&nbsp;<em><strong>C</strong></em>&nbsp;components
of the quaternion, respectively. As usual, nothing untoward happens
if what should be magnitudes are negative numbers or angles are out
of their natural ranges, as symmetries and periodicities kick in.</p>
<p>In this version of our implementation of quaternions, there is no
analogue of the complex value operation&nbsp;<code class="western">arg</code>&nbsp;as
the situation is somewhat more complicated. Unit quaternions are
linked both to rotations in&nbsp;<em><strong>R</strong></em><em><strong><sup>3</sup></strong></em>&nbsp;and
in&nbsp;<em><strong>R</strong></em><em><strong><sup>4</sup></strong></em>,
and the correspondences are not too complicated, but there is
currently a lack of standard (de facto or de jure) matrix library
with which the conversions could work. This should be remedied in a
further revision. In the mean time, an example of how this could be
done is presented here for&nbsp;<a href="http://www.boost.org/doc/libs/1_66_0/libs/math/example/HSO3.hpp" target="_top"><em><strong>R</strong></em><em><strong><sup>3</sup></strong></em></a>,
and here for&nbsp;<a href="http://www.boost.org/doc/libs/1_66_0/libs/math/example/HSO4.hpp" target="_top"><em><strong>R</strong></em><em><strong><sup>4</sup></strong></em></a>&nbsp;(<a href="http://www.boost.org/doc/libs/1_66_0/libs/math/example/HSO3SO4.cpp" target="_top">example
test file</a>).</p>
<h2 class="western">Exception Safety</h2>
<h2 class="western">Hash</h2>
<h2 class="western"><strong>Possible implementation</strong></h2>
<p>See <a href="http://www.boost.org/doc/libs/1_66_0/boost/math/quaternion.hpp">Boost.Math</a>
implementation.</p>
<h2 class="western">References</h2>
<p><a href="http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/quaternions.html">Boost.Math</a>
documentation.</p>
<h2 class="western">Open issues</h2>
<p>1) Should be added or not support for&nbsp;</p>
</body>
</html>