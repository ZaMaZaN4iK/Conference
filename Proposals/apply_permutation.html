<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 5.4.6.2 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="2018-03-26T19:26:55.257700528"/>
	<meta name="created" content="00:00:00">
	<style type="text/css">
		h2.cjk { font-family: "WenQuanYi Micro Hei" }
		h2.ctl { font-family: "Lohit Devanagari" }
	</style>
</head>
<body lang="ru-RU" dir="ltr">
<h1 align="center"><strong>Proposal for Additional Functions for
Permutations</strong></h1>
<p align="right"><strong>Document number:&nbsp;</strong></p>
<p align="right"><strong>Date:&nbsp;</strong></p>
<p align="right"><strong>Project:&nbsp;</strong>Programming Language
C++</p>
<p align="right"><strong>Reference:&nbsp;</strong>ISO/IEC IS
14882:2017(E)</p>
<p align="right"><strong>Reply to:</strong>&nbsp;Alexander Zaitsev</p>
<p align="right">zamazan4ik@tut.by</p>
<p align="right">&nbsp;</p>
<h2 class="western" align="left"><strong>Overview</strong></h2>
<p>At the current time in the standard, we already have functions for
working with permutations. But this set of functions is not enough
for full-fledged work with permutations: <strong>is_permutation</strong>,
<strong>next_permutation</strong>, <strong>prev_permutation</strong>.</p>
<p>Quite often there are situations when you just need to rearrange
the elements in some specific order. At this point, the developer
will have to write this functionality manually. But we can simplify
this routine by providing standard functions.</p>
<p>It is proposed to add two new functions: <strong>apply_permutation</strong>,
<strong>apply_reverse_permutation</strong>.</p>
<h2 class="western">Description</h2>
<p>The algorithms transform the item sequence according to index
sequence order.</p>
<p>The routine <strong>apply_permutation</strong> takes a item
sequence and a order sequence. It reshuffles item sequence according
to order sequence. Every value in order sequence means where the item
comes from. Order sequence needs to be exactly a permutation of the
sequence [0, 1, ... , N], where N is the biggest index in the item
sequence (zero-indexed).</p>
<p><br/>
The routine <strong>apply_reverse_permutation</strong> takes
a item sequence and a order sequence. It will reshuffle item sequence
according to order sequence. Every value in order sequence means
where the item goes to. Order sequence needs to be exactly a
permutation of the sequence [0, 1, ... , N], where N is the biggest
index in the item sequence (zero-indexed).</p>
<h2 class="western"><strong>Header &lt;algorithm&gt;</strong></h2>
<p>namespace std</p>
<p>{</p>
<p>...</p>
<p>template&lt;typename RandomAccessIterator1, typename
RandomAccessIterator2&gt;<br/>
constexpr void
apply_permutation(RandomAccessIterator1 item_begin,
RandomAccessIterator1 item_end,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; RandomAccessIterator2 ind_begin,
RandomAccessIterator2 ind_end);</p>
<p>template&lt;typename RandomAccessIterator1, typename
RandomAccessIterator2&gt;<br/>
constexpr void
apply_reverse_permutation(RandomAccessIterator1 item_begin,
RandomAccessIterator1 item_end,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; RandomAccessIterator2 ind_begin, RandomAccessIterator2
ind_end);</p>
<p>...</p>
<p>}</p>
<h2 class="western"><strong>Details</strong></h2>
<p>template&lt;typename RandomAccessIterator1, typename
RandomAccessIterator2&gt;<br/>
constexpr void
<strong>apply_permutation</strong>(RandomAccessIterator1 item_begin,
RandomAccessIterator1 item_end,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; RandomAccessIterator2 ind_begin,
RandomAccessIterator2 ind_end);</p>
<p>Reorder item sequence with index sequence order.&nbsp;</p>
<p>Order sequence must be zero-indexed.</p>
<p>Item and order sequences get permuted.</p>
<p>Works on empty sequences.</p>
<p><strong>Parameters</strong>:</p>
<p>item_begin&nbsp; -&nbsp; The start of the item sequence.</p>
<p>item_end - One past the end of the item sequence.</p>
<p>ind_begin - The start of the index sequence.</p>
<p>item_end - One past the end of the index sequence.</p>
<p><strong>Note</strong>: Item sequence size should be equal to index
size. Otherwise behavior is undefined.</p>
<p><strong>Complexity</strong>: O(N).</p>
<p>&nbsp;</p>
<p>template&lt;typename RandomAccessIterator1, typename
RandomAccessIterator2&gt;<br/>
constexpr void
<strong>apply_reverse_permutation</strong>(RandomAccessIterator1
item_begin, RandomAccessIterator1 item_end,<br/>
&nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RandomAccessIterator2
ind_begin, RandomAccessIterator2 ind_end);</p>
<p>Reorder item sequence with index sequence order.</p>
<p>Order sequence must be zero-indexed.</p>
<p>Item and order sequences get permuted.</p>
<p>Works on empty sequences.</p>
<p><strong>Parameters</strong>:</p>
<p>item_begin&nbsp; -&nbsp; The start of the item sequence.</p>
<p>item_end - One past the end of the item sequence.</p>
<p>ind_begin - The start of the index sequence.</p>
<p>item_end - One past the end of the index sequence.</p>
<p><strong>Note</strong>: Item sequence size should be equal to index
size. Otherwise behavior is undefined.</p>
<p><strong>Complexity</strong>: O(N).</p>
<h2 class="western">Iterator Requirements</h2>
<p><strong>apply_permutation</strong> and
<strong>apply_reverse_permutation</strong>&nbsp;work only on
RandomAccess iterators. RandomAccess iterators required both for item
and index sequences.</p>
<h2 class="western">Exception Safety</h2>
<p><strong>apply_permutation</strong>&nbsp;and
<strong>apply_reverse_permutation</strong>&nbsp;take their parameters
by iterators or reference, and do not depend upon any global state.
Therefore, <strong>apply_permutation</strong>&nbsp;and
<strong>apply_reverse_permutation</strong>&nbsp;provide the strong
exception guarantee.</p>
<h2 class="western"><strong>Possible implementation</strong></h2>
<p>template&lt;typename RandomAccessIterator1, typename
RandomAccessIterator2&gt;<br/>
constexpr void
apply_permutation(RandomAccessIterator1 item_begin,
RandomAccessIterator1 item_end,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; RandomAccessIterator2 ind_begin,
RandomAccessIterator2 ind_end)<br/>
{<br/>
&nbsp; &nbsp; using Diff =
typename
std::iterator_traits&lt;RandomAccessIterator1&gt;::difference_type;<br/>
&nbsp;
&nbsp; using std::swap;<br/>
&nbsp; &nbsp; Diff size =
std::distance(item_begin, item_end);<br/>
&nbsp; &nbsp; for (Diff i =
0; i &lt; size; i++)<br/>
&nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp;
auto current = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; while (i !=
ind_begin[current])<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; auto next = ind_begin[current];<br/>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(item_begin[current],
item_begin[next]);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
ind_begin[current] = current;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; current = next;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp;
&nbsp; &nbsp; &nbsp; ind_begin[current] = current;<br/>
&nbsp; &nbsp;
}<br/>
}</p>
<p>template&lt;typename RandomAccessIterator1, typename
RandomAccessIterator2&gt;<br/>
constexpr void
apply_reverse_permutation(RandomAccessIterator1 item_begin,
RandomAccessIterator1 item_end,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; RandomAccessIterator2 ind_begin, RandomAccessIterator2
ind_end)<br/>
{<br/>
&nbsp; &nbsp; using Diff = typename
std::iterator_traits&lt;RandomAccessIterator2&gt;::difference_type;<br/>
&nbsp;
&nbsp; using std::swap;<br/>
&nbsp; &nbsp; Diff length =
std::distance(item_begin, item_end);<br/>
&nbsp; &nbsp; for (Diff i =
0; i &lt; length; i++)<br/>
&nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp;
&nbsp; while (i != ind_begin[i])<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Diff next = ind_begin[i];<br/>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(item_begin[i],
item_begin[next]);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
swap(ind_begin[i], ind_begin[next]);<br/>
&nbsp; &nbsp; &nbsp; &nbsp;
}<br/>
&nbsp; &nbsp; }<br/>
}</p>
<h2 class="western">Example</h2>
<p>#include &lt;vector&gt;<br/>
#include &lt;iostream&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>int main ( int /*argc*/, char * /*argv*/ [] )<br/>
{<br/>
{<br/>
&nbsp;
&nbsp; std::cout &lt;&lt; &quot;apply_permutation with
iterators:\n&quot;;<br/>
&nbsp; &nbsp; std::vector&lt;int&gt; vec{1,
2, 3, 4, 5}, order{4, 2, 3, 1, 0};</p>
<p>&nbsp; &nbsp; std::apply_permutation(vec.begin(), vec.end(),
order.begin(), order.end());<br/>
&nbsp; &nbsp; for (const auto&amp;
x : vec)<br/>
&nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp;
std::cout &lt;&lt; x &lt;&lt; &quot;, &quot;;<br/>
&nbsp; &nbsp; }<br/>
&nbsp;
&nbsp; std::cout &lt;&lt; std::endl;<br/>
}<br/>
{<br/>
&nbsp; &nbsp;
std::cout &lt;&lt; &quot;apply_reverse_permutation with
iterators:\n&quot;;<br/>
&nbsp; &nbsp; std::vector&lt;int&gt; vec{1,
2, 3, 4, 5}, order{4, 2, 3, 1, 0};</p>
<p>&nbsp; &nbsp; std::apply_reverse_permutation(vec.begin(),
vec.end(), order.begin(), order.end());<br/>
&nbsp; &nbsp; for (const
auto&amp; x : vec)<br/>
&nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp;
std::cout &lt;&lt; x &lt;&lt; &quot;, &quot;;<br/>
&nbsp; &nbsp; }<br/>
&nbsp;
&nbsp; std::cout &lt;&lt; std::endl;<br/>
}<br/>
return 0;<br/>
}</p>
<h2 class="western">Open questions</h2>
<p>1) Question about naming is open. <b>apply_reverse_permutation </b><span style="font-weight: normal">is
a little bit ugly.</span></p>
<h2 class="western">References</h2>
<p><a href="https://github.com/boostorg/algorithm/blob/develop/include/boost/algorithm/apply_permutation.hpp">Boost.Algorithm</a>
implementation</p>
<p>Microsoft Developer &quot;Old new thing&quot; blog: <a href="https://blogs.msdn.microsoft.com/oldnewthing/20170102-00/?p=95095">1</a>,
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170103-00/?p=95105">2</a>,
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170104-00/?p=95115">3</a>,
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170109-00/?p=95145">4</a>,
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170110-00/?p=95155">5</a>,
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170111-00/?p=95165">6</a></p>
</body>
</html>